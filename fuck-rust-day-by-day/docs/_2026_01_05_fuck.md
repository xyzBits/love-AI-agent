这观察非常敏锐！`&'static str` 确实是最常见的，因为字符串字面量（如 `"hello"`）在编译时就被直接硬编码进二进制文件的**只读数据段（RODATA）**里了，天然就是 static 的。

要得到其他类型的 `&'static` 引用，通常有两种手段：

1. **编译时：** 使用 `static` 关键字定义全局变量。
2. **运行时：** 使用“内存泄漏”技术（`Box::leak`）将堆上的数据“永生化”。

以下是你要的三个具体例子：

---

### 1. `&'static i32`：常量提升或全局变量

#### 方法 A：使用 `static` 关键字 (最标准)

如果你定义一个全局变量，它的内存地址是固定的，因此你可以安全地获取它的 `'static` 引用。

```rust
// 静态变量存储在程序的“数据段”中，地址固定
static MY_LUCKY_NUMBER: i32 = 42;

fn main() {
    let x: &'static i32 = &MY_LUCKY_NUMBER;
    println!("My static number: {}", x);
}

```

#### 方法 B：常量提升 (编译器黑魔法)

Rust 编译器很聪明，对于简单的字面量数字，如果你写 `&100`，它会悄悄把它放在静态内存区，从而允许你把它当 `'static` 用。

```rust
fn main() {
    // 编译器看你写了 &100，它自动把它提升为 static
    let x: &'static i32 = &100; 
    println!("{}", x);
}

```

---

### 2. `&'static MyStruct`：全局配置单例

这在写**全局配置（Config）**时非常常见。

```rust
struct Config {
    debug_mode: bool,
    app_name: &'static str,
}

// 声明一个全局静态结构体
static APP_CONFIG: Config = Config {
    debug_mode: true,
    app_name: "SuperApp",
};

fn main() {
    // 获取结构体的 static 引用
    let config: &'static Config = &APP_CONFIG;
    
    if config.debug_mode {
        println!("Starting {}", config.app_name);
    }
}

```

> **注意：** 现代 Rust 开发中，如果结构体初始化很复杂（比如需要读取环境变量），我们通常使用 `std::sync::OnceLock`（Rust 1.70+）来实现这种全局单例。

---

### 3. `&'static Vec<String>`：运行时“内存泄漏” (最硬核)

`Vec` 是分配在堆（Heap）上的，且在运行时才能决定大小，所以你不能直接写 `static V = vec![...]`（因为 `vec!` 宏涉及到堆分配，不能在编译期运行）。

**如果你在运行时创建了一个 `Vec`，但想让它活得跟程序一样长，变成 `&'static`，该怎么办？**

**答案：使用 `Box::leak`。**

它的原理是：原本 `Box` 在离开作用域时会释放内存。`Box::leak` 的作用是：“我要放弃这个 Box 的所有权，我不 Drop 它了，让它永远漂浮在堆上吧。” 既然永远不释放，那它就是 `'static` 的了。

```rust
fn main() {
    // 1. 在运行时动态创建一个 Vec
    let my_vec = vec!["Rust".to_string(), "Go".to_string(), "C++".to_string()];

    // 2. 将其装入 Box (移动到堆上)
    let boxed_vec = Box::new(my_vec);

    // 3. 【关键】显式泄漏内存！
    // Box::leak 会消费掉 Box，并返回一个 &'static mut T
    // 这里的 static_vec 类型是 &'static Vec<String>
    let static_vec: &'static Vec<String> = Box::leak(boxed_vec);

    // 4. 现在你可以把这个引用传给任何需要 'static 的地方了（比如 thread::spawn）
    std::thread::spawn(move || {
        // 这里的 static_vec 是引用，但因为它是 static 的，所以可以在线程间安全传递
        println!("我们在子线程里访问: {:?}", static_vec);
    }).join().unwrap();
    
    // 注意：这块内存直到程序结束前永远不会被回收
}

```

### 总结

`&'static T` 的来源主要就这三个地方：

1. **字符串字面量** -> `&'static str` (存在代码段/只读数据段)。
2. **`static` 声明的全局变量** -> `&'static T` (存在静态数据段)。
3. **`Box::leak()`** -> `&'static T` (存在堆上，但永不释放)。

以后看到 `&'static T` (非 `str`)，你大概率是在看某种**全局单例**或者**故意泄漏的配置数据**。